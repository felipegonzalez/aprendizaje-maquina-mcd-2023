[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Aprendizaje Máquina",
    "section": "",
    "text": "Temario y referencias\nTodas las notas y material del curso estarán en este repositorio.\n\nIntroducción al aprendizaje máquina\nMétodos locales y regresión lineal\nIngeniería de variables de entrada\nRegularización\nProblemas de clasificación y regresión logística\nMétodos de remuestreo y validación cruzada\nRedes neuronales\nÁrboles, bosques aleatorios y boosting\nDiagnóstico y mejora en problemas de aprendizaje supervisado\nComponentes principales y análisis de conglomerados\n\n\nEvaluación\n\nTareas semanales (20%)\nExamen parcial (30% práctico, 20% teórico)\nUn examen final (30% práctico)\n\n\n\nMaterial\nCada semestre las notas cambian, en algunas partes considerablemente. Las de este semestre están en este repositorio, incluyendo ejemplos, ejercicios y tareas.\n\n\nReferencias principales\n\nAn Introduction to Statistical Learning, James et al. (2014)\nDeep Learning, Goodfellow, Bengio, y Courville (2016)\nTidy Modeling with R, Kuhn y Silge (2022)\n\n\n\nOtras referencias\n\nPattern Recognition and Machine Learning, Bishop (2006)\nThe Elements of Statistical Learning, Hastie, Tibshirani, y Friedman (2017)\nPredicción conforme\n\n\n\nSoftware: R y Rstudio\nPara hacer las tareas y exámenes pueden usar cualquier lenguaje o flujo de trabajo que les convenga (R o Python, por ejemplo) - el único requisito esté basado en código y no point-and-click. En lo posible utilizamos librerías especializadas que se pueden utilizar desde varias plataformas (keras, por ejemplo).\n\n\n\n\nBishop, Christopher M. 2006. Pattern Recognition and Machine Learning (Information Science and Statistics). Secaucus, NJ, USA: Springer-Verlag New York, Inc.\n\n\nGoodfellow, Ian, Yoshua Bengio, y Aaron Courville. 2016. Deep Learning. MIT Press.\n\n\nHastie, Trevor, Robert Tibshirani, y Jerome Friedman. 2017. The Elements of Statistical Learning. Springer Series en Statistics. Springer New York Inc. http://web.stanford.edu/~hastie/ElemStatLearn/.\n\n\nJames, Gareth, Daniela Witten, Trevor Hastie, y Robert Tibshirani. 2014. An Introduction to Statistical Learning: With Applications in R. Springer Publishing Company, Incorporated. http://www-bcf.usc.edu/~gareth/ISL/.\n\n\nKuhn, M., y J. Silge. 2022. Tidy Modeling with R. O’Reilly Media. https://books.google.com.mx/books?id=9cJ6EAAAQBAJ."
  },
  {
    "objectID": "01-introduccion.html#qué-es-aprendizaje-de-máquina-machine-learning",
    "href": "01-introduccion.html#qué-es-aprendizaje-de-máquina-machine-learning",
    "title": "1  Introducción",
    "section": "1.1 ¿Qué es aprendizaje de máquina (machine learning)?",
    "text": "1.1 ¿Qué es aprendizaje de máquina (machine learning)?\nMétodos computacionales para aprender de datos con el fin de producir reglas para mejorar el desempeño en alguna tarea o toma de decisión.\nEn este curso nos enfocamos en las tareas de aprendizaje supervisado (predecir o estimar una variable respuesta a partir de datos de entrada) y aprendizaje no supervisado (describir estructuras interesantes en datos, donde no necesariamente hay una respuesta que predecir). Existe también aprendizaje por refuerzo, en donde buscamos aprender a tomar decisiones en un entorno en donde la decisión afecta directa e inmediatamente al entorno.\n\nEjemplos de tareas de aprendizaje:\n\nPredecir si un cliente de tarjeta de crédito va a caer en impago en los próximos tres meses.\nReconocer palabras escritas a mano (OCR).\nDetectar llamados de ballenas en grabaciones de boyas.\nEstimar el ingreso mensual de un hogar a partir de las características de la vivienda, posesiones y equipamiento y localización geográfica.\nDividir a los clientes de Netflix según sus gustos.\nRecomendar artículos a clientes de un programa de lealtad o servicio online.\n\nLas razones usuales para intentar resolver estos problemas computacionalmente son diversas:\n\nQuisiéramos obtener una respuesta barata, rápida, automatizada, y con suficiente precisión. Por ejemplo, reconocer caracteres en una placa de coche de una fotografía se puede hacer por personas, pero eso es lento y costoso. Igual oír cada segundo de grabación de las boyas para saber si hay ballenas o no. Hacer mediciones directas del ingreso de un hogar requiere mucho tiempo y esfuerzo.\nQuisiéramos superar el desempeño actual de los expertos o de reglas simples utilizando datos: por ejemplo, en la decisión de dar o no un préstamo a un solicitante, puede ser posible tomar mejores decisiones con algoritmos que con evaluaciones personales o con reglas simples que toman en cuenta el ingreso mensual, por ejemplo.\nAl resolver estos problemas computacionalmente tenemos oportunidad de aprender más del problema que nos interesa: estas soluciones forman parte de un ciclo de análisis de datos donde podemos aprender de una forma más concentrada cuáles son características y patrones importantes de nuestros datos.\n\nEs posible aproximarse a todos estos problemas usando reglas (por ejemplo, si los pixeles del centro de la imagen están vacíos, entonces es un cero, si el crédito total es mayor al 50% del ingreso anual, declinar el préstamo, etc). Las razones para no tomar un enfoque de reglas construidas “a mano”:\n\nCuando conjuntos de reglas creadas a mano se desempeñan mal (por ejemplo, para otorgar créditos, reconocer caracteres, etc.)\nReglas creadas a mano pueden ser difíciles de mantener (por ejemplo, un corrector ortográfico), pues para problemas interesantes muchas veces se requieren grandes cantidades de reglas. Por ejemplo: ¿qué búsquedas www se enfocan en dar direcciones como resultados? ¿cómo filtrar comentarios no aceptables en foros?"
  },
  {
    "objectID": "01-introduccion.html#ejemplo-reglas-y-aprendizaje",
    "href": "01-introduccion.html#ejemplo-reglas-y-aprendizaje",
    "title": "1  Introducción",
    "section": "1.2 Ejemplo: reglas y aprendizaje",
    "text": "1.2 Ejemplo: reglas y aprendizaje\nLectura de un medidor mediante imágenes. Supongamos que en una infraestructura donde hay medidores análogos (de agua, electricidad, gas, etc.) que no se comunican. ¿Podríamos pensar en utilizar fotos tomadas automáticamente para medir el consumo?\nPor ejemplo, consideramos el siguiente problema (tomado de aquí, ver código y datos):\n\nlibrary(imager)\nlibrary(tidyverse)\nlibrary(gt)\nset.seed(437)\npath_img &lt;- \"../datos/medidor/\"\npath_full_imgs &lt;- list.files(path = path_img, full.names = TRUE)\nmedidor &lt;- load.image(sample(path_full_imgs, 1))\npar(mar = c(1, 1, 1, 1))\nplot(medidor, axes = FALSE)\n\n\n\n\nNótese que las imágenes y videos son matrices o arreglos de valores de pixeles, por ejemplo estas son las dimensiones para una imagen:\n\ndim(medidor)\n\n[1] 142 142   1   3\n\n\nEn este caso, la imagen es de 193 x 193 pixeles y tiene tres canales, o tres matrices de 193 x 193 donde la entrada de cada matriz es la intensidad del canal correspondiente. Buscámos hacer cálculos con estas matrices para extraer la información que queremos. En este caso, construiremos estos cálculos a mano.\nPrimero filtramos (extraemos canal rojo y azul, restamos, difuminamos y aplicamos un umbral):\n\nmedidor_rojo &lt;- medidor |&gt;  R() \nmedidor_azul &lt;- medidor |&gt; B()\nmedidor_1 &lt;- (medidor_rojo - medidor_azul) |&gt; isoblur(5)\naguja &lt;-  medidor_1 |&gt;  imager::threshold(\"90%\", approx = FALSE)\n\n\n\n\n\n\nLogramos extraer la aguja, aunque hay algo de ruido adicional. Una estrategia es extraer la componente conexa más grande (que debería corresponder a la aguja), y luego calcular su orientación. Una manera fácil es encontrar una recta que vaya del centro de la imagen hasta el punto más alejado del centro (aunque quizá puedes pensar maneras más robustas de hacer esto):\n\ncalcular_punta &lt;- function(pixset){\n  centro &lt;- floor(dim(pixset)[1:2] / 2)\n  # segmentar en componentes conexas\n  componentes &lt;- split_connected(pixset)\n  # calcular la más grande\n  num_pixeles &lt;- map_dbl(componentes, sum)\n  ind_maxima &lt;- which.max(num_pixeles)\n  pixset_tbl &lt;- as_tibble(componentes[[ind_maxima]]) |&gt; \n    mutate(dist = (x - centro[1])^2 + (y - centro[2])^2) |&gt; \n    top_n(1, dist)  |&gt; \n    mutate(x_1 = x - centro[1], y_1 = y - centro[2])\n  pixset_tbl[1, ] \n}\n\nY ahora podemos aplicar el proceso de arriba a todas la imágenes:\n\npath_imgs &lt;- list.files(path = path_img)\n\npath_full_imgs &lt;- list.files(path = path_img, full.names = TRUE)\n# en este caso los datos están etiquetados\ny_imagenes &lt;- path_imgs |&gt; str_sub(1, 3) |&gt; as.numeric()\n# procesar algunas imagenes\nset.seed(82)\nindice_imgs &lt;- sample(1:length(path_full_imgs), 500)\nangulos &lt;- path_full_imgs[indice_imgs] |&gt; \n    map( ~ load.image(.x)) |&gt;  \n    map(~ R(.x) - B(.x)) |&gt; \n    map( ~ isoblur(.x, 5)) |&gt; \n    map( ~ imager::threshold(.x, \"90%\")) |&gt; \n    map( ~ calcular_punta(.x)) |&gt; \n  bind_rows()\n\n\nangulos_tbl &lt;- angulos |&gt; \n  mutate(y_medidor = y_imagenes[indice_imgs])\nggplot(angulos_tbl, \n    aes(x = 180 * atan2(y_1, x_1) / pi + 90, y = y_medidor)) +\n  geom_point() + xlab(\"Ángulo\")\n\n\n\n\nEl desempeño no es muy malo pero tiene algunas fallas grandes. Quizá refinando nuestro pipeline de procesamiento podemos mejorarlo.\n\nPor el contrario, en el enfoque de aprendizaje, comenzamos con un conjunto de datos etiquetado (por una persona, por un método costoso, etc.), y utilizamos alguna estructura general para aprender a producir la respuesta a partir de las imágenes. Por ejemplo, en este caso podríamos una red convolucional sobre los valores de los pixeles de la imagen:\n\nlibrary(keras)\n# usamos los tres canales de la imagen\nimagenes &lt;- map(path_full_imgs, ~ image_load(.x, target_size = c(64, 64)))\nimgs_array &lt;-  imagenes |&gt;  map(~ image_to_array(.x)) \nimgs_array &lt;- map(imgs_array, ~ array_reshape(.x, c(1, 64, 64, 3)))\nx &lt;- abind::abind(imgs_array, along = 1)\nset.seed(25311)\nindices_entrena &lt;- sample(1:dim(x)[1], size = 4200)\n# generar lotes de datos de las imágenes originales\ngenerador_1 &lt;- image_data_generator(\n  rescale = 1/255,\n  rotation_range = 5,\n  zoom_range = 0.05,\n  horizontal_flip = FALSE,\n  vertical_flip = FALSE,\n  fill_mode = \"nearest\"\n)\ngenerador_entrena &lt;- flow_images_from_data(\n  x = x[indices_entrena,,,],\n  y = y_imagenes[indices_entrena] / 10,\n  generator = generador_1,\n  shuffle = TRUE,\n  batch_size = 64\n)\n\n\nmodelo_aguja &lt;- keras_model_sequential() |&gt;\n  layer_conv_2d(input_shape = c(64, 64, 3), \n    filters = 32, kernel_size = c(5, 5)) |&gt; \n  layer_max_pooling_2d(pool_size = c(2, 2)) |&gt;\n  layer_conv_2d(filters = 32, kernel_size = c(5, 5)) |&gt; \n  layer_max_pooling_2d(pool_size = c(2, 2)) |&gt; \n  layer_conv_2d(filters = 16, kernel_size = c(3, 3)) |&gt; \n  layer_max_pooling_2d(pool_size = c(2, 2)) |&gt; \n  layer_flatten() |&gt; \n  layer_dropout(0.2) |&gt; \n  layer_dense(units = 100, activation = \"sigmoid\") |&gt;\n  layer_dropout(0.2) |&gt; \n  layer_dense(units = 100, activation = \"sigmoid\") |&gt;\n  layer_dropout(0.2) |&gt; \n  layer_dense(units = 1, activation = 'linear')\n\nAjustamos el modelo:\n\nmodelo_aguja |&gt; compile(\n  loss = \"mse\",\n  optimizer = optimizer_adam(learning_rate = 0.0005),\n  metrics = c('mae')\n)                                                                                                        \n# Entrenar\nmodelo_aguja |&gt; fit(\n  generador_entrena,\n  epochs = 200,\n  verbose = TRUE, \n  validation_data = list(x = x[-indices_entrena,,,], \n                         y = y_imagenes[-c(indices_entrena)] / 10)\n)\nsave_model_hdf5(modelo_aguja, \"cache/modelo-aguja.h5\")\n\n\nmodelo &lt;- load_model_hdf5(\"cache/modelo-aguja.h5\")\nmodelo\n\nModel: \"sequential_2\"\n________________________________________________________________________________\n Layer (type)                       Output Shape                    Param #     \n================================================================================\n conv2d_8 (Conv2D)                  (None, 60, 60, 32)              2432        \n max_pooling2d_8 (MaxPooling2D)     (None, 30, 30, 32)              0           \n conv2d_7 (Conv2D)                  (None, 26, 26, 32)              25632       \n max_pooling2d_7 (MaxPooling2D)     (None, 13, 13, 32)              0           \n conv2d_6 (Conv2D)                  (None, 11, 11, 16)              4624        \n max_pooling2d_6 (MaxPooling2D)     (None, 5, 5, 16)                0           \n flatten_2 (Flatten)                (None, 400)                     0           \n dropout_8 (Dropout)                (None, 400)                     0           \n dense_8 (Dense)                    (None, 100)                     40100       \n dropout_7 (Dropout)                (None, 100)                     0           \n dense_7 (Dense)                    (None, 100)                     10100       \n dropout_6 (Dropout)                (None, 100)                     0           \n dense_6 (Dense)                    (None, 1)                       101         \n================================================================================\nTotal params: 82,989\nTrainable params: 82,989\nNon-trainable params: 0\n________________________________________________________________________________\n\n\nY observamos que obtenemos predicciones prometedoras:\n\npreds &lt;- predict(modelo, x[-indices_entrena,,,])\npreds_tbl &lt;- tibble(y = y_imagenes[-c(indices_entrena)] / 10, preds = preds)\nggplot(preds_tbl, aes(x = preds, y = y)) +\n  geom_jitter(alpha = 0.5) +\n  geom_abline(colour = 'red')\n\n\n\n\nDe forma que podemos resolver este problema con algoritmos generales, sin tener que aplicar métodos sofisticados de procesamiento de imágenes. El enfoque de aprendizaje es particularmente efectivo cuando hay cantidades grandes de datos poco ruidosos, y aunque en este ejemplo los dos enfoques dan resultados razonables, en procesamiento de imágenes es cada vez más común usar redes neuronales grandes para resolver este tipo de problemas."
  },
  {
    "objectID": "01-introduccion.html#medicioncostosa",
    "href": "01-introduccion.html#medicioncostosa",
    "title": "1  Introducción",
    "section": "1.3 Ejemplo: mediciones costosas",
    "text": "1.3 Ejemplo: mediciones costosas\nEn algunos casos, el estándar de la medición que nos interesa es uno que es costoso de cumplir: a veces se dice que etiquetar los datos es costoso. Un ejemplo es producir las estimaciones de ingreso trimestral de un hogar que se recolecta en la ENIGH (ver aquí). En este caso particular, se utiliza esta encuesta como datos etiquetados para poder estimar el ingreso de otros hogares que no están en la muestra del ENIGH, pero para los que se conocen características de las vivienda, características de los integrantes, y otras medidas que son más fácilmente recolectadas en encuestas de opinión.\nVeremos otro ejemplo: estimar el valor de mercado de las casas en venta de una región. Es posible que tengamos un inventario de casas con varias de sus características registradas, pero producir estimaciones correctas de su valor de mercado puede requerir de inspecciones costosas de expertos, o tomar aproximaciones imprecisas de esta cantidad (por ejemplo, cuál es el precio ofertado).\nUtilizaremos datos de casas que se vendieron en Ames, Iowa en cierto periodo. En este caso, conocemos el valor a la que se vendió una casa. Buscamos producir una estimación para otras casas para las cuales conocemos características como su localización, superficie en metros cuadrados, año de construcción, espacio de estacionamiento, y así sucesivamente. Estas medidas son más fáciles de recolectar, y quisiéramos producir una estimación de su precio de venta en términos de estas medidas.\nEn este ejemplo intentaremos una forma simple de predecir.\n\nlibrary(tidymodels)\nlibrary(patchwork)\nsource(\"../R/casas_traducir_geo.R\")\nset.seed(68821)\n# dividir muestra\ncasas_split &lt;- initial_split(casas, prop = 0.75)\n# obtener muestra de entrenamiento\ncasas_entrena &lt;- training(casas_split)\n# graficar\ng_1 &lt;- ggplot(casas_entrena, aes(x = precio_miles)) +\n  geom_histogram()\ng_2 &lt;- ggplot(casas_entrena, aes(x = area_hab_m2, \n                          y = precio_miles, \n                          colour = condicion_venta)) +\n  geom_point() \ng_1 + g_2\n\n\n\n\nLa variable de condición de venta no podemos utilizarla para predecir, pues sólo la conocemos una vez que la venta se hace. Podemos ver en lugar de eso solamente las de condición normal. Consideramos además del área habitable, por ejemplo, la calidad general de terminados:\n\nggplot(casas_entrena |&gt;  \n       filter(condicion_venta == \"Normal\") |&gt;  \n       mutate(calidad_grupo = \n        cut(calidad_gral, breaks = c(0, 5, 7, 8, 10))), \n  aes(x = area_hab_m2, \n      y = precio_miles,\n      colour = calidad_grupo)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, formula = \"y ~ x\")\n\n\n\n\nPrecio vs área y calidad\n\n\n\ng_1\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nPrecio vs área y calidad\n\n\n\n\nVemos que estas dos variables que hemos usado explican buena parte de la variación de los precios de las casas. Podemos examinar otras variables como la existencia y tamaño del garage:\n\nggplot(casas_entrena |&gt;  filter(condicion_venta == \"Normal\"),\n       aes(x = area_hab_m2, y = precio_miles, colour = area_garage_m2)) +\n  geom_point(alpha = 0.5) + facet_wrap(~ (area_garage_m2 == 0))\n\n\n\n\nY quizá podríamos proponer una fórmula simple de la forma:\n\\[Precio = a_{calidad} + b_{calidad}\\textrm{Area} + c \\textrm{AreaGarage} + d\\textrm{TieneGarage}\\]\ndonde los valores de \\(a_{calidad}, b_{calidad}, c, d\\) podríamos estimarlos de los datos. La pendiente de Area dependende de la calificación de la calidad de los terminados.\nNuestro proceso comenzaría entonces construir los datos para usar en el modelo:\n\nreceta_casas &lt;- \n  recipe(precio_miles ~ area_hab_m2 + calidad_gral + \n           area_garage_m2, \n         data = casas_entrena) |&gt;  \n  step_cut(calidad_gral, breaks = c(3, 5, 6, 7, 8)) |&gt;  \n  step_normalize(starts_with(\"area\")) |&gt; \n  step_mutate(tiene_garage = ifelse(area_garage_m2 &gt; 0, 1, 0)) |&gt; \n  step_dummy(calidad_gral) |&gt; \n  step_interact(terms = ~ area_hab_m2:starts_with(\"calidad_gral\")) \n\nDefinimos el tipo de modelo que queremos ajustar, creamos un flujo y ajustamos\n\n# modelo\ncasas_modelo &lt;- linear_reg() |&gt; \n  set_engine(\"lm\")\n# flujo\nflujo_casas &lt;- workflow() |&gt; \n  add_recipe(receta_casas) |&gt; \n  add_model(casas_modelo)\n# ajustar flujo\najuste &lt;- fit(flujo_casas, casas_entrena)\najuste\n\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Recipe\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\n5 Recipe Steps\n\n• step_cut()\n• step_normalize()\n• step_mutate()\n• step_dummy()\n• step_interact()\n\n── Model ───────────────────────────────────────────────────────────────────────\n\nCall:\nstats::lm(formula = ..y ~ ., data = data)\n\nCoefficients:\n                       (Intercept)                         area_hab_m2  \n                           111.124                              22.505  \n                    area_garage_m2                        tiene_garage  \n                            12.014                               3.230  \n               calidad_gral_X.3.5.                 calidad_gral_X.5.6.  \n                            30.104                              54.623  \n               calidad_gral_X.6.7.                 calidad_gral_X.7.8.  \n                            79.565                             119.639  \n              calidad_gral_X.8.10.   area_hab_m2_x_calidad_gral_X.3.5.  \n                           217.099                              -7.942  \n area_hab_m2_x_calidad_gral_X.5.6.   area_hab_m2_x_calidad_gral_X.6.7.  \n                             2.839                              14.141  \n area_hab_m2_x_calidad_gral_X.7.8.  area_hab_m2_x_calidad_gral_X.8.10.  \n                            14.221                              -1.421  \n\n\nY ahora podemos hacer predicciones para nuevos datos no observados en el entrenamiento:\n\nset.seed(8)\ncasas_prueba &lt;- testing(casas_split) \nejemplos &lt;- casas_prueba|&gt; sample_n(5)\npredict(ajuste, ejemplos) |&gt; \n  bind_cols(ejemplos |&gt; select(precio_miles, area_hab_m2)) |&gt; \n  arrange(desc(precio_miles)) |&gt; gt() |&gt; \n  fmt_number(columns = everything(), decimals = 1)\n\n\n\n\n\n  \n    \n    \n      .pred\n      precio_miles\n      area_hab_m2\n    \n  \n  \n    242.3\n275.0\n152.9\n    177.3\n181.0\n155.6\n    169.3\n175.5\n132.1\n    123.1\n133.0\n117.8\n    115.6\n128.5\n90.2\n  \n  \n  \n\n\n\n\nY finalmente podemos evaluar nuestro modelo. En este casos mostramos diversas métricas como ejemplo:\n\nmetricas &lt;- metric_set(mape, mae, rmse)\nmetricas(casas_prueba |&gt; bind_cols(predict(ajuste, casas_prueba)), \n     truth = precio_miles, estimate = .pred) |&gt; gt() |&gt; \n  fmt_number(columns = where(is_double), decimals = 1)\n\n\n\n\n\n  \n    \n    \n      .metric\n      .estimator\n      .estimate\n    \n  \n  \n    mape\nstandard\n14.1\n    mae\nstandard\n23.4\n    rmse\nstandard\n33.3\n  \n  \n  \n\n\n\n\n\ncasas_prueba_f &lt;- filter(casas_prueba,\n  condicion_venta %in% c(\"Normal\", \"Partial\", \"Abnorml\"))\nggplot(casas_prueba_f |&gt;\n       bind_cols(predict(ajuste, casas_prueba_f)),\n       aes(x = .pred, y = precio_miles)) +\n  geom_point() +\n  geom_abline(colour = \"red\") + facet_wrap(~ condicion_venta)\n\n\n\n\nEste modelo tiene algunos defectos y todavía tiene error considerablemente grande. La mejora sin embargo podemos cuantificarla con un modelo base o benchmark. En este caso utilizamos el siguiente modelo simple, cuya predicción es el promedio de entrenamiento:\n\n# nearest neighbors es grande, así que la predicción\n# es el promedio de precio en entrenamiento\ncasas_promedio &lt;- nearest_neighbor(\n    neighbors = 1000, weight_func = \"rectangular\") |&gt;\n  set_mode(\"regression\") |&gt; \n  set_engine(\"kknn\")\nworkflow_base &lt;- workflow() |&gt; \n  add_recipe(receta_casas) |&gt; \n  add_model(casas_promedio)\najuste_base &lt;- fit(workflow_base, casas_entrena)\nmetricas(casas_prueba |&gt; bind_cols(predict(ajuste_base, casas_prueba)), \n     truth = precio_miles, estimate = .pred)|&gt; gt() |&gt; \n  fmt_number(columns = where(is_double), decimals = 1)\n\n\n\n\n\n  \n    \n    \n      .metric\n      .estimator\n      .estimate\n    \n  \n  \n    mape\nstandard\n33.4\n    mae\nstandard\n54.8\n    rmse\nstandard\n77.2"
  },
  {
    "objectID": "01-introduccion.html#aprendizaje-supervisado-y-no-supervisado",
    "href": "01-introduccion.html#aprendizaje-supervisado-y-no-supervisado",
    "title": "1  Introducción",
    "section": "1.4 Aprendizaje supervisado y no supervisado",
    "text": "1.4 Aprendizaje supervisado y no supervisado\nLas tareas de aprendizaje se dividen en dos grandes partes: aprendizaje supervisado y aprendizaje no supervisado.\nEn Aprendizaje supervisado buscamos construir un modelo o algoritmo para predecir o estimar un target o una respuesta a partir de ciertas variables de entrada.\nPredecir y estimar, en este contexto, se refieren a cosas similares. Generalmente se usa predecir cuando se trata de variables que no son observables ahora, sino en el futuro, y estimar cuando nos interesan variables actuales que no podemos observar ahora por costos o por la naturaleza del fenómeno.\nPor ejemplo, para identificar a los clientes con alto riesgo de impago de tarjeta de crédito, utilizamos datos históricos de clientes que han pagado y no han pagado. Con estos datos entrenamos un algoritmo para detectar anticipadamente los clientes con alto riesgo de impago.\nUsualmente dividimos los problemas de aprendizaje supervisado en dos tipos, dependiendo de la variables salida:\n\nProblemas de regresión: cuando la salida es una variable numérica. El ejemplo de estimación de ingreso es un problema de regresión\nProblemas de clasificación: cuando la salida es una variable categórica. El ejemplo de detección de dígitos escritos a manos es un problema de clasificación.\n\nEn contraste, en Aprendizaje no supervisado no hay target o variable respuesta. Buscamos modelar y entender las relaciones entre variables y entre observaciones, o patrones importantes o interesantes en los datos.\nLos problemas supervisados tienen un objetivo claro: hacer las mejores predicciones posibles bajo ciertas restricciones. Los problemas no supervisados tienden a tener objetivos más vagos, y por lo mismo pueden ser más difíciles."
  },
  {
    "objectID": "99-referencias.html",
    "href": "99-referencias.html",
    "title": "Referencias",
    "section": "",
    "text": "Bishop, Christopher M. 2006. Pattern Recognition and Machine\nLearning (Information Science and Statistics). Secaucus, NJ, USA:\nSpringer-Verlag New York, Inc.\n\n\nGoodfellow, Ian, Yoshua Bengio, and Aaron Courville. 2016. Deep\nLearning. MIT Press.\n\n\nHastie, Trevor, Robert Tibshirani, and Jerome Friedman. 2017. The\nElements of Statistical Learning. Springer Series in Statistics.\nSpringer New York Inc. http://web.stanford.edu/~hastie/ElemStatLearn/.\n\n\nJames, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani.\n2014. An Introduction to Statistical Learning: With Applications in\nr. Springer Publishing Company, Incorporated. http://www-bcf.usc.edu/~gareth/ISL/.\n\n\nKuhn, M., and J. Silge. 2022. Tidy Modeling with r. O’Reilly\nMedia. https://books.google.com.mx/books?id=9cJ6EAAAQBAJ."
  }
]